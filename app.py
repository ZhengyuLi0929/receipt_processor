from flask import Flask, request, jsonify, abort
import uuid
import re
import math
from datetime import datetime, time

from threading import Lock

app = Flask(__name__)


# ========================THREAD-SAFETY=============================
# In-memory storage for receipts with thread safety
receipts = {}
receipts_lock = Lock()



# =============================ENDPOINTS=============================
# Endpoint: /receipts/process
# Method: POST
# Payload: Receipt JSON
# Response: JSON containing an id for the receipt.
# Description: Takes in a JSON receipt (see example in the example directory) and returns a JSON object with an ID generated by your code.
#              The ID returned is the ID that should be passed into /receipts/{id}/points to get the number of points the receipt was awarded.
@app.route('/receipts/process', methods=['POST'])
def process_receipt():
    """
    Processes a receipt by calculating points and storing it with a unique ID.
    """
    data = request.get_json()
    if not data:
        abort(400, description="Invalid JSON payload.")
    
    # Validate receipt data
    try:
        validate_receipt(data)
    except ValueError as e:
        abort(400, description=str(e))
    
    # Calculate points
    points = calculate_points(data)
    
    # Generate unique ID and store receipt
    receipt_id = str(uuid.uuid4())
    with receipts_lock:
        receipts[receipt_id] = {
            'receipt': data,
            'points': points
        }
    
    # Return the ID in the response
    return jsonify({"id": receipt_id}), 200


# Endpoint: /receipts/{id}/points
# Method: GET
# Payload: Receipt JSON
# Response: A JSON object containing the number of points awarded.
# Description: A simple Getter endpoint that looks up the receipt by the ID and returns an object specifying the points awarded.
@app.route('/receipts/<receipt_id>/points', methods=['GET'])
def get_points(receipt_id):
    """
    Retrieves the points awarded for a receipt by its ID.
    """
    with receipts_lock:
        receipt_entry = receipts.get(receipt_id)
    
    if not receipt_entry:
        abort(404, description="Receipt not found.")
    
    return jsonify({"points": receipt_entry['points']}), 200





# =============================HELPER FUNCTIONS=============================
def validate_receipt(receipt):
    """
    Validates the receipt data to ensure all required fields are present and correctly formatted.
    Raises ValueError if validation fails.
    """
    required_fields = ['retailer', 'purchaseDate', 'purchaseTime', 'items', 'total']
    for field in required_fields:
        if field not in receipt:
            raise ValueError(f"Missing required field: {field}")
    
    # validate retailer
    if not isinstance(receipt['retailer'], str) or not receipt['retailer'].strip():
        raise ValueError("Retailer name must be a non-empty string")
    
    # validate purchaseDate
    try:
        datetime.strptime(receipt['purchaseDate'], "%Y-%m-%d")
    except ValueError:
        raise ValueError("purchaseDate must be in 'YYYY-MM-DD' format")
    
    # validate purchaseTime
    try:
        datetime.strptime(receipt['purchaseTime'], "%H:%M")
    except ValueError:
        raise ValueError("purchaseTime must be in 24hrs format like 'HH:MM', no AM or PM")
    
    # validate total
    try:
        total = float(receipt['total'])
        if total <= 0:
            raise ValueError("Total must be positive")
        
    except ValueError:
        raise ValueError("Total must be a valid number. ")
    
    # validate items
    if not isinstance(receipt['items'], list) or not receipt['items']:
        raise ValueError("Items must be a non-empty list.")
    for item in receipt['items']:
        if 'shortDescription' not in item or 'price' not in item:
            raise ValueError("Each item must contain 'shortDescription' and 'price'.")
        if not isinstance(item['shortDescription'], str) or not item['shortDescription'].strip():
            raise ValueError("Item 'shortDescription' must be a non-empty string.")
        try:
            price = float(item['price'])
            if price <= 0:
                raise ValueError("Item 'price' must be a positive number.")
        except ValueError:
            raise ValueError("Item 'price' must be a valid number.")

def calculate_points(receipt):
    """
    Calculates the total points awarded for the receipt based on the specified rules.
    """
    points = 0
    
    # rule 1: One point for every alphanumeric character in the retailer name
    retailer = receipt['retailer']
    alphanumeric_count = len(re.findall(r'[A-Za-z0-9]', retailer))
    points += alphanumeric_count
    
    # rule 2: 50 points if the total is a round dollar
    total = float(receipt['total'])
    if (total * 100) % 100 == 0:
        points += 50
    
    # rule 3: 25 points if the total is a multiple of 0.25
    if (total * 100) % 25 == 0:
        points += 25
    
    # rule 4: 5 points for every two items
    item_count = len(receipt['items'])
    points += (item_count // 2) * 5
    
    # rule 5: 0.2 points for items with description length a multiple of 3, then round up
    for item in receipt['items']:
        description = item['shortDescription'].strip()
        if len(description) % 3 == 0:
            price = float(item['price'])
            item_points = math.ceil(price * 0.2)
            points += item_points
    
    # rule 6: 6 points if the day in the purchase date is odd
    purchase_date = datetime.strptime(receipt['purchaseDate'], "%Y-%m-%d")
    if purchase_date.day % 2 == 1:
        points += 6
    
    # rule 7: 10 points if the time is after 2:00pm and before 4:00pm
    purchase_time = datetime.strptime(receipt['purchaseTime'], "%H:%M").time()
    start_time = time(14, 0)
    end_time = time(16, 0)  
    if start_time <= purchase_time < end_time:
        points += 10
    
    return points

# =============================MAIN=============================
if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080, debug=True)
